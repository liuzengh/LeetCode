## 动态规划
###  最优子结构
最优子结构规定的是子问题与原问题的关系

动态规划要解决的都是一些问题的最优解，即从很多解决问题的方案中找到最优的一个。当我们在求一个问题最优解的时候，如果可以把这个问题分解成多个子问题，然后递归地找到每个子问题的最优解，最后通过一定的数学方法对各个子问题的最优解进行组合得出最终的结果。总结来说就是一个问题的最优解是由它的各个子问题的最优解决定的。
###  重复子问题

重复子问题规定的是子问题与子问题的关系。

当我们在递归地寻找每个子问题的最优解的时候，有可能会会重复地遇到一些更小的子问题，而且这些子问题会重叠地出现在子问题里，出现这样的情况，会有很多重复的计算，动态规划可以保证每个重叠的子问题只会被求解一次。当重复的问题很多的时候，动态规划可以减少很多重复的计算。

重复子问题不是保证解的正确性必须的，但是如果递归求解子问题时，没有出现重复子问题，则没有必要用动态规划，直接普通的递归就可以了

### 关键要素

1. 状态定义：定义子问题，保持子问题空间尽可能简单，只在必要的时候才扩展它。
2. 状态转移：原问题和子问题之间的关系，子问题和子问题之间的关系。
3. 边界条件
4. 初始化


## 线性动态规划

其中线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。这里问题规模为 i 的含义是考虑前 i 个元素 [0..i] 时问题的解。
1. 状态定义：dp[n] := [0..n] 上问题的解
2. 状态转移：dp[n] = f(dp[n-1], ..., dp[0])


从以上状态定义和状态转移可以看出，大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。

按照问题的输入格式，线性动态规划解决的问题主要是单串，双串，矩阵上的问题，因为在单串，双串，矩阵上问题规模可以完全用位置表示，并且位置的大小就是问题规模的大小。因此从前往后推位置就相当于从小到大推问题规模。

单串、双串、矩阵上的问题

### 单串

#### 单串：依赖比 i 小的 O(1) 个子问题

1. 定义子问题：定义dp[i]为以nums[i]结尾的最大数组和
2. 定义原问题和子问题的关系：
dp[i]中肯定包含nums[i]，但是包不包括nums[i]之前的一段连续的区间数呢？如果dp[i-1]大于0，则dp[i] = num[i]+dp[i-1]，此时的dp[i]肯定比只包含nums[i]更大。
3. 边界条件：要考虑 i - 1 必须大于等于0， i 小于等于 n - 1, n为数组的长度。
4. 初始化：dp[0] = nums[0]
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums);
        for(int i = 1; i < nums.size(); ++i)
            dp[i] = nums[i] + max(0, dp[i-1]);
        return *max_element(dp.begin(), dp.end());
    }
};
```

#### 单串：依赖比 i 小的 O(n) 个子问题|最长上升子序列

1. 定义子问题：定义dp[i]为以nums[i]结尾的最长递增子序列的长度
2. 定义原问题和子问题的关系：
dp[i]肯定至少等于1，但是包不包括nums[i]之前的子序列的长度呢？如果nums[i]大于nums[k](0<=k<i)，则dp[i] = 1+ max{dp[k]}
1. 边界条件：要考虑 0<= k < i, 0 <= i < n, n为数组的长度。
2. 初始化：dp[0] = 1;

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        for(int i = 1; i < nums.size(); ++i)
            for(int k = i - 1; k>=0; --k)
                if(nums[i] > nums[k])
                    dp[i] = max(dp[i], dp[k] + 1);
        return *max_element(dp.begin(), dp.end());
    }
};
```

#### 单串问题：最经典单串 LIS 系列

LIS 是单串上最经典的问题，它的状态设计是单串动态规划最经典的状态设计。很多单串的题目。状态设计都是启发自这道题的设计，因此需要专门练习，加深印象。

#### 单串问题：最大子数组和系列
从动态规划角度讲，最大子数组和是以一类较简单的 DP 问题，但它的状态设计比较经典，同时也是很多问题的基础组件，需要专门掌握。

|序号|详细分类|中文题目| 代码| 备注
|:-  |:-      |:-      |:- |:- |
| LC300 |最经典的单串LIS系列|最长上升子序列|[C++](DP/LC300.cpp) |加二分查找降低时间复杂度为(nlogn)|
| LC673 |最经典的单串LIS系列|最长递增子序列的个数|[C++](DP/LC673.cpp) | 加额外的数组统计出现的次数 |
| LC354 |最经典的单串LIS系列|俄罗斯套娃信封问题| [C++](DP/LC354.cpp)| 定义信封上的偏序关系，排序 |
| LC53 |最大子数组和系列|最大子序列和|[C++](DP/LC53.cpp) | |
| LC152 |最大子数组和系列|乘积最大子数组|[C++](DP/LC152.cpp) | 需要分别保存最大的正数和最小负数 |
| LC918 |最大子数组和系列|环形子数组的最大和|[C++](DP/LC918.cpp) | 循环数组的处理，**建议二刷** |
